version: "3.8"

services:
  db:
    image: postgres:15
    container_name: zta_postgres
    restart: always
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "zta"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - network_aziendale
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    command: postgres -c config_file=/etc/postgresql/postgresql.conf
    volumes:
      - ./db/init_tables.sql:/docker-entrypoint-initdb.d/init_tables.sql
      - ./db/postgresql.conf:/etc/postgresql/postgresql.conf
      - postgres_logs:/var/log/postgresql
    ports:
      - "5433:5432"

  db_seeder:
    build:
      context: ./db
      dockerfile: Dockerfile.seeder
    container_name: zta_db_seeder
    depends_on:
      db:
        condition: service_healthy 
    environment:
      DB_HOST: ${DB_HOST}
      DB_PORT: ${DB_PORT}
      DB_NAME: ${POSTGRES_DB}
      DB_USER: ${POSTGRES_USER}
      DB_PASSWORD: ${POSTGRES_PASSWORD}
    command: bash -c "until pg_isready -h $DB_HOST -p $DB_PORT; do echo 'Waiting for PostgreSQL...'; sleep 2; done; python3 /docker-entrypoint-initdb.d/seed.py"  # Esegui lo script di seeding
    volumes:
      - ./db/seed.py:/docker-entrypoint-initdb.d/seed.py
    networks:
      - network_aziendale    

  pep:
    build: ./pep
    container_name: zta_pep   
    depends_on:
      db:
        condition: service_healthy 
    networks:
      - network_aziendale
      - network_vpn
      - network_domestica
      - network_pubblica
    environment:
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT}
      - DB_NAME=${DB_NAME}
      - DB_USER=${DB_USER}
      - DB_PASSWORD=${DB_PASSWORD}
      - PEP_PORT=${PEP_PORT}
      - PDP_VALUTA=${PDP_VALUTA}
    volumes:
      - pep_logs:/mnt/pep_logs
    # ports:
    #   - "8002:8002"

  pdp:
    build: ./pdp
    container_name: zta_pdp
    depends_on:
      - splunk
    networks:
      - network_aziendale
    environment:
      - SPLUNK_HOST=${SPLUNK_HOST}
      - SPLUNK_PORT=${SPLUNK_PORT}
      - SPLUNK_TOKEN=${SPLUNK_HEC_TOKEN}
      - SPLUNK_USERNAME=${SPLUNK_USERNAME}
      - SPLUNK_PASSWORD=${SPLUNK_PASSWORD}
      - PDP_PORT=${PDP_PORT}
      - LOG_DIR=${LOG_DIR}
      - LOG_FILE=${LOG_FILE}
      - POLICY_FILE=${POLICY_FILE}
    volumes:
      - pdp_logs:/mnt/pdp_logs
      - ./policies.json:/app/policies.json
    # ports:
    #   - "8001:8001"

  iptables:
    build: ./iptables
    container_name: zta_iptables
    cap_add:
      - NET_ADMIN
    volumes:
      - ./iptables/iptables.rules:/iptables.rules
    networks:
      - network_aziendale
      - network_vpn
      - network_domestica
      - network_pubblica
    privileged: true
    depends_on:
      db:  # iptables deve dipendere dal db, per garantirne l'avvio prima
          condition: service_healthy

  squid:
    image: sameersbn/squid
    container_name: zta_squid
    volumes:
      - ./squid/squid.conf:/etc/squid/squid.conf
      - squid_logs:/var/log/squid
    networks:
      - network_aziendale
      - network_vpn
      - network_domestica
      - network_pubblica
    depends_on:
      - iptables
      - pep
    # ports:
    #   - "3129:3129" # proxy intercettato

  snort:
    build: ./snort  
    container_name: zta_snort
    cap_add:
      - NET_ADMIN  # Permette al contenitore di configurare la rete
    networks:
      - network_aziendale
      - network_vpn
      - network_domestica
      - network_pubblica
    privileged: true
    ports:
      - "5140:5140/udp"  # Esporta la porta per gli avvisi
    volumes:
      - ./snort/rules:/etc/snort/rules
      - snort_logs:/var/log/snort
    depends_on: 
      - squid            

  splunk:
    build: ./splunk
    container_name: zta_splunk
    environment:
      - SPLUNK_START_ARGS=--accept-license --no-prompt --answer-yes
      - SPLUNK_IGNORE_SSL_ERRORS=true
      - SPLUNK_PASSWORD=${SPLUNK_PASSWORD}
    networks:
      - network_aziendale
    ports:
      - "8000:8000" # Web UI (accessibile via browser)
      - "8088:8088" # HTTP Event Collector (HEC)
      - "8089:8089" # REST API di Splunk Management
      - "9997:9997" # Universal Forwarder
    volumes:
      - splunk_data:/opt/splunk  # Docker-managed volume, non scrive localmente
      - snort_logs:/mnt/snort_logs
      - squid_logs:/mnt/squid_logs
      - postgres_logs:/mnt/postgres_logs
      - pdp_logs:/mnt/pdp_logs
      - pep_logs:/mnt/pep_logs
    depends_on:
      - snort

## 4 client per ogni rete

  client_aziendale:
    build: ./client
    container_name: client_aziendale
    networks:
      - network_aziendale
    environment:
      - SPLUNK_HEC_TOKEN=${SPLUNK_HEC_TOKEN}
    command: ["sleep", "infinity"]

  client_vpn:
    build: ./client
    container_name: client_vpn
    networks:
      - network_vpn
    environment:
      - SPLUNK_HEC_TOKEN=${SPLUNK_HEC_TOKEN}
    command: ["sleep", "infinity"]

  client_domestica:
    build: ./client
    container_name: client_domestica
    networks:
      - network_domestica
    environment:
      - SPLUNK_HEC_TOKEN=${SPLUNK_HEC_TOKEN}
    command: ["sleep", "infinity"]

  client_pubblica:
    build: ./client
    container_name: client_pubblica
    networks:
      - network_pubblica
    environment:
      - SPLUNK_HEC_TOKEN=${SPLUNK_HEC_TOKEN}
    command: ["sleep", "infinity"]

volumes:
  splunk_data:
    driver: local
  snort_logs:
    driver: local
  squid_logs:
    driver: local
  postgres_logs:
    driver: local
  pdp_logs:
    driver: local
  pep_logs:
    driver: local

networks:
  network_aziendale:
    driver: bridge
    ipam:
      config:
        - subnet: 10.10.1.0/24

  network_vpn:
    driver: bridge
    ipam:
      config:
        - subnet: 10.10.2.0/24

  network_domestica:
    driver: bridge
    ipam:
      config:
        - subnet: 10.10.3.0/24

  network_pubblica:
    driver: bridge
    ipam:
      config:
        - subnet: 10.10.4.0/24

